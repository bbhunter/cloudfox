package commands

import (
	"context"
	"fmt"
	"strings"

	orgsservice "github.com/BishopFox/cloudfox/gcp/services/organizationsService"
	"github.com/BishopFox/cloudfox/globals"
	"github.com/BishopFox/cloudfox/internal"
	gcpinternal "github.com/BishopFox/cloudfox/internal/gcp"
	"github.com/spf13/cobra"
)

var GCPOrganizationsCommand = &cobra.Command{
	Use:     globals.GCP_ORGANIZATIONS_MODULE_NAME,
	Aliases: []string{"org", "orgs", "hierarchy"},
	Short:   "Enumerate GCP organization hierarchy",
	Long: `Enumerate GCP organization, folder, and project hierarchy.

Features:
- Lists accessible organizations
- Shows folder structure
- Maps project relationships
- Displays resource hierarchy tree
- Shows ancestry paths for projects`,
	Run: runGCPOrganizationsCommand,
}

// ------------------------------
// Module Struct with embedded BaseGCPModule
// ------------------------------
type OrganizationsModule struct {
	gcpinternal.BaseGCPModule

	// Module-specific fields
	Organizations []orgsservice.OrganizationInfo
	Folders       []orgsservice.FolderInfo
	Projects      []orgsservice.ProjectInfo
	Ancestry      [][]orgsservice.HierarchyNode
	LootMap       map[string]*internal.LootFile
}

// ------------------------------
// Output Struct implementing CloudfoxOutput interface
// ------------------------------
type OrganizationsOutput struct {
	Table []internal.TableFile
	Loot  []internal.LootFile
}

func (o OrganizationsOutput) TableFiles() []internal.TableFile { return o.Table }
func (o OrganizationsOutput) LootFiles() []internal.LootFile   { return o.Loot }

// ------------------------------
// Command Entry Point
// ------------------------------
func runGCPOrganizationsCommand(cmd *cobra.Command, args []string) {
	// Initialize command context
	cmdCtx, err := gcpinternal.InitializeCommandContext(cmd, globals.GCP_ORGANIZATIONS_MODULE_NAME)
	if err != nil {
		return // Error already logged
	}

	// Create module instance
	module := &OrganizationsModule{
		BaseGCPModule: gcpinternal.NewBaseGCPModule(cmdCtx),
		Organizations: []orgsservice.OrganizationInfo{},
		Folders:       []orgsservice.FolderInfo{},
		Projects:      []orgsservice.ProjectInfo{},
		Ancestry:      [][]orgsservice.HierarchyNode{},
		LootMap:       make(map[string]*internal.LootFile),
	}

	// Initialize loot files
	module.initializeLootFiles()

	// Execute enumeration
	module.Execute(cmdCtx.Ctx, cmdCtx.Logger)
}

// ------------------------------
// Module Execution
// ------------------------------
func (m *OrganizationsModule) Execute(ctx context.Context, logger internal.Logger) {
	orgsSvc := orgsservice.New()

	// Get organizations
	orgs, err := orgsSvc.SearchOrganizations()
	if err != nil {
		logger.InfoM(fmt.Sprintf("Could not enumerate organizations: %v", err), globals.GCP_ORGANIZATIONS_MODULE_NAME)
	} else {
		m.Organizations = orgs
	}

	// Get all folders
	folders, err := orgsSvc.SearchAllFolders()
	if err != nil {
		logger.InfoM(fmt.Sprintf("Could not enumerate folders: %v", err), globals.GCP_ORGANIZATIONS_MODULE_NAME)
	} else {
		m.Folders = folders
	}

	// Get all projects
	projects, err := orgsSvc.SearchProjects("")
	if err != nil {
		logger.InfoM(fmt.Sprintf("Could not enumerate projects: %v", err), globals.GCP_ORGANIZATIONS_MODULE_NAME)
	} else {
		m.Projects = projects
	}

	// Get ancestry for each specified project
	for _, projectID := range m.ProjectIDs {
		ancestry, err := orgsSvc.GetProjectAncestry(projectID)
		if err != nil {
			logger.InfoM(fmt.Sprintf("Could not get ancestry for project %s: %v", projectID, err), globals.GCP_ORGANIZATIONS_MODULE_NAME)
		} else {
			m.Ancestry = append(m.Ancestry, ancestry)
		}
	}

	// Generate loot
	m.generateLoot()

	// Report findings
	logger.SuccessM(fmt.Sprintf("Found %d organization(s), %d folder(s), %d project(s)",
		len(m.Organizations), len(m.Folders), len(m.Projects)), globals.GCP_ORGANIZATIONS_MODULE_NAME)

	// Write output
	m.writeOutput(ctx, logger)
}

// ------------------------------
// Loot File Management
// ------------------------------
func (m *OrganizationsModule) initializeLootFiles() {
	m.LootMap["org-hierarchy"] = &internal.LootFile{
		Name:     "org-hierarchy",
		Contents: "# GCP Organization Hierarchy\n# Generated by CloudFox\n\n",
	}
	m.LootMap["org-all-projects"] = &internal.LootFile{
		Name:     "org-all-projects",
		Contents: "",
	}
	m.LootMap["org-gcloud-commands"] = &internal.LootFile{
		Name:     "org-gcloud-commands",
		Contents: "# Organization Enumeration Commands\n# Generated by CloudFox\n\n",
	}
}

func (m *OrganizationsModule) generateLoot() {
	// All project IDs
	for _, proj := range m.Projects {
		m.LootMap["org-all-projects"].Contents += proj.ProjectID + "\n"
	}

	// Hierarchy visualization
	for _, org := range m.Organizations {
		orgID := strings.TrimPrefix(org.Name, "organizations/")
		m.LootMap["org-hierarchy"].Contents += fmt.Sprintf("Organization: %s (%s)\n", org.DisplayName, orgID)

		// Find folders directly under this org
		for _, folder := range m.Folders {
			if folder.Parent == org.Name {
				m.addFolderToHierarchy(folder, 1)
			}
		}

		// Find projects directly under this org
		for _, proj := range m.Projects {
			if proj.Parent == org.Name {
				m.LootMap["org-hierarchy"].Contents += fmt.Sprintf("  └── Project: %s (%s)\n", proj.DisplayName, proj.ProjectID)
			}
		}
		m.LootMap["org-hierarchy"].Contents += "\n"
	}

	// Gcloud commands
	for _, org := range m.Organizations {
		orgID := strings.TrimPrefix(org.Name, "organizations/")
		m.LootMap["org-gcloud-commands"].Contents += fmt.Sprintf(
			"# Organization: %s\n"+
				"gcloud organizations describe %s\n"+
				"gcloud organizations get-iam-policy %s\n"+
				"gcloud resource-manager folders list --organization=%s\n"+
				"gcloud projects list --filter='parent.id=%s'\n\n",
			org.DisplayName,
			orgID,
			orgID,
			orgID,
			orgID,
		)
	}

	for _, folder := range m.Folders {
		folderID := strings.TrimPrefix(folder.Name, "folders/")
		m.LootMap["org-gcloud-commands"].Contents += fmt.Sprintf(
			"# Folder: %s\n"+
				"gcloud resource-manager folders describe %s\n"+
				"gcloud resource-manager folders get-iam-policy %s\n\n",
			folder.DisplayName,
			folderID,
			folderID,
		)
	}
}

func (m *OrganizationsModule) addFolderToHierarchy(folder orgsservice.FolderInfo, depth int) {
	indent := strings.Repeat("  ", depth)
	folderID := strings.TrimPrefix(folder.Name, "folders/")
	m.LootMap["org-hierarchy"].Contents += fmt.Sprintf("%s├── Folder: %s (%s)\n", indent, folder.DisplayName, folderID)

	// Find child folders
	for _, childFolder := range m.Folders {
		if childFolder.Parent == folder.Name {
			m.addFolderToHierarchy(childFolder, depth+1)
		}
	}

	// Find projects under this folder
	for _, proj := range m.Projects {
		if proj.Parent == folder.Name {
			m.LootMap["org-hierarchy"].Contents += fmt.Sprintf("%s  └── Project: %s (%s)\n", indent, proj.DisplayName, proj.ProjectID)
		}
	}
}

// ------------------------------
// Output Generation
// ------------------------------
func (m *OrganizationsModule) writeOutput(ctx context.Context, logger internal.Logger) {
	// Organizations table
	orgsHeader := []string{
		"Organization ID",
		"Display Name",
		"State",
		"Directory ID",
	}

	var orgsBody [][]string
	for _, org := range m.Organizations {
		orgID := strings.TrimPrefix(org.Name, "organizations/")
		orgsBody = append(orgsBody, []string{
			orgID,
			org.DisplayName,
			org.State,
			org.DirectoryID,
		})
	}

	// Folders table
	foldersHeader := []string{
		"Folder ID",
		"Display Name",
		"Parent",
		"State",
	}

	var foldersBody [][]string
	for _, folder := range m.Folders {
		folderID := strings.TrimPrefix(folder.Name, "folders/")
		foldersBody = append(foldersBody, []string{
			folderID,
			folder.DisplayName,
			folder.Parent,
			folder.State,
		})
	}

	// Projects table
	projectsHeader := []string{
		"Project ID",
		"Display Name",
		"Parent",
		"State",
	}

	var projectsBody [][]string
	for _, proj := range m.Projects {
		projectsBody = append(projectsBody, []string{
			proj.ProjectID,
			proj.DisplayName,
			proj.Parent,
			proj.State,
		})
	}

	// Ancestry table
	ancestryHeader := []string{
		"Project",
		"Ancestry Path",
	}

	var ancestryBody [][]string
	for _, ancestry := range m.Ancestry {
		if len(ancestry) > 0 {
			// Build ancestry path string
			var path []string
			projectID := ""
			for _, node := range ancestry {
				if node.Type == "project" {
					projectID = node.ID
				}
				path = append(path, fmt.Sprintf("%s:%s", node.Type, node.ID))
			}
			ancestryBody = append(ancestryBody, []string{
				projectID,
				strings.Join(path, " -> "),
			})
		}
	}

	// Collect loot files
	var lootFiles []internal.LootFile
	for _, loot := range m.LootMap {
		if loot.Contents != "" {
			lootFiles = append(lootFiles, *loot)
		}
	}

	// Build tables
	var tables []internal.TableFile

	if len(orgsBody) > 0 {
		tables = append(tables, internal.TableFile{
			Name:   "organizations",
			Header: orgsHeader,
			Body:   orgsBody,
		})
	}

	if len(foldersBody) > 0 {
		tables = append(tables, internal.TableFile{
			Name:   "folders",
			Header: foldersHeader,
			Body:   foldersBody,
		})
	}

	if len(projectsBody) > 0 {
		tables = append(tables, internal.TableFile{
			Name:   "projects",
			Header: projectsHeader,
			Body:   projectsBody,
		})
	}

	if len(ancestryBody) > 0 {
		tables = append(tables, internal.TableFile{
			Name:   "ancestry",
			Header: ancestryHeader,
			Body:   ancestryBody,
		})
	}

	output := OrganizationsOutput{
		Table: tables,
		Loot:  lootFiles,
	}

	// Write output using HandleOutputSmart with scope support
	err := internal.HandleOutputSmart(
		"gcp",
		m.Format,
		m.OutputDirectory,
		m.Verbosity,
		m.WrapTable,
		"project",           // scopeType
		m.ProjectIDs,        // scopeIdentifiers
		m.ProjectIDs,        // scopeNames (same as IDs for GCP projects)
		m.Account,
		output,
	)
	if err != nil {
		logger.ErrorM(fmt.Sprintf("Error writing output: %v", err), globals.GCP_ORGANIZATIONS_MODULE_NAME)
		m.CommandCounter.Error++
	}
}
