package commands

import (
	"context"
	"fmt"
	"strings"
	"sync"

	privescservice "github.com/BishopFox/cloudfox/gcp/services/privescService"
	"github.com/BishopFox/cloudfox/globals"
	"github.com/BishopFox/cloudfox/internal"
	gcpinternal "github.com/BishopFox/cloudfox/internal/gcp"
	"github.com/spf13/cobra"
)

var GCPPrivescCommand = &cobra.Command{
	Use:     globals.GCP_PRIVESC_MODULE_NAME,
	Aliases: []string{"pe", "escalate", "priv"},
	Short:   "Identify privilege escalation paths in GCP projects",
	Long: `Analyze GCP IAM policies to identify privilege escalation opportunities.

This module examines IAM bindings to find principals with dangerous permissions
that could be used to escalate privileges within the GCP environment.

Detected privilege escalation methods include:
- Service Account Token Creation (iam.serviceAccounts.getAccessToken)
- Service Account Key Creation (iam.serviceAccountKeys.create)
- Project/Folder/Org IAM Policy Modification
- Compute Instance Metadata Injection (SSH keys, startup scripts)
- Cloud Functions/Run Deployment with SA Identity
- Cloud Build SA Abuse
- GKE Cluster Access
- Secret Manager Access
- Signed URL/JWT Generation`,
	Run: runGCPPrivescCommand,
}

type PrivescModule struct {
	gcpinternal.BaseGCPModule
	Paths   []privescservice.PrivescPath
	LootMap map[string]*internal.LootFile
	mu      sync.Mutex
}

type PrivescOutput struct {
	Table []internal.TableFile
	Loot  []internal.LootFile
}

func (o PrivescOutput) TableFiles() []internal.TableFile { return o.Table }
func (o PrivescOutput) LootFiles() []internal.LootFile   { return o.Loot }

func runGCPPrivescCommand(cmd *cobra.Command, args []string) {
	cmdCtx, err := gcpinternal.InitializeCommandContext(cmd, globals.GCP_PRIVESC_MODULE_NAME)
	if err != nil {
		return
	}

	module := &PrivescModule{
		BaseGCPModule: gcpinternal.NewBaseGCPModule(cmdCtx),
		Paths:         []privescservice.PrivescPath{},
		LootMap:       make(map[string]*internal.LootFile),
	}
	module.initializeLootFiles()
	module.Execute(cmdCtx.Ctx, cmdCtx.Logger)
}

func (m *PrivescModule) Execute(ctx context.Context, logger internal.Logger) {
	m.RunProjectEnumeration(ctx, logger, m.ProjectIDs, globals.GCP_PRIVESC_MODULE_NAME, m.processProject)

	if len(m.Paths) == 0 {
		logger.InfoM("No privilege escalation paths found", globals.GCP_PRIVESC_MODULE_NAME)
		return
	}

	logger.SuccessM(fmt.Sprintf("Found %d privilege escalation path(s)", len(m.Paths)), globals.GCP_PRIVESC_MODULE_NAME)
	m.writeOutput(ctx, logger)
}

func (m *PrivescModule) processProject(ctx context.Context, projectID string, logger internal.Logger) {
	if globals.GCP_VERBOSITY >= globals.GCP_VERBOSE_ERRORS {
		logger.InfoM(fmt.Sprintf("Analyzing privilege escalation in project: %s", projectID), globals.GCP_PRIVESC_MODULE_NAME)
	}

	svc := privescservice.New()
	paths, err := svc.AnalyzeProjectPrivesc(projectID)
	if err != nil {
		m.CommandCounter.Error++
		gcpinternal.HandleGCPError(err, logger, globals.GCP_PRIVESC_MODULE_NAME,
			fmt.Sprintf("Could not analyze privilege escalation in project %s", projectID))
		return
	}

	m.mu.Lock()
	m.Paths = append(m.Paths, paths...)
	for _, path := range paths {
		m.addPathToLoot(path)
	}
	m.mu.Unlock()
}

func (m *PrivescModule) initializeLootFiles() {
	m.LootMap["privesc-exploit-commands"] = &internal.LootFile{
		Name:     "privesc-exploit-commands",
		Contents: "# GCP Privilege Escalation Exploit Commands\n# Generated by CloudFox\n\n",
	}
}

func (m *PrivescModule) addPathToLoot(path privescservice.PrivescPath) {
	m.LootMap["privesc-exploit-commands"].Contents += fmt.Sprintf(
		"# Method: %s\n"+
			"# Principal: %s (%s)\n"+
			"# Project: %s\n"+
			"# Target: %s\n"+
			"# Permissions: %s\n"+
			"%s\n\n",
		path.Method,
		path.Principal, path.PrincipalType,
		path.ProjectID,
		path.TargetResource,
		strings.Join(path.Permissions, ", "),
		path.ExploitCommand,
	)
}

func (m *PrivescModule) writeOutput(ctx context.Context, logger internal.Logger) {
	// Privesc table
	// Reads: Source principal can perform action (method) on target resource
	header := []string{
		"Project Name",
		"Project ID",
		"Source Principal",
		"Source Principal Type",
		"Action (Method)",
		"Target Resource",
		"Permissions",
	}

	var body [][]string
	for _, path := range m.Paths {
		body = append(body, []string{
			m.GetProjectName(path.ProjectID),
			path.ProjectID,
			path.Principal,
			path.PrincipalType,
			path.Method,
			path.TargetResource,
			strings.Join(path.Permissions, ", "),
		})
	}

	// Collect loot files
	var lootFiles []internal.LootFile
	for _, loot := range m.LootMap {
		if loot.Contents != "" && !strings.HasSuffix(loot.Contents, "# Generated by CloudFox\n\n") {
			lootFiles = append(lootFiles, *loot)
		}
	}

	tables := []internal.TableFile{}
	if len(body) > 0 {
		tables = append(tables, internal.TableFile{
			Name:   "privesc",
			Header: header,
			Body:   body,
		})
	}

	output := PrivescOutput{Table: tables, Loot: lootFiles}

	scopeNames := make([]string, len(m.ProjectIDs))
	for i, id := range m.ProjectIDs {
		scopeNames[i] = m.GetProjectName(id)
	}

	err := internal.HandleOutputSmart(
		"gcp",
		m.Format,
		m.OutputDirectory,
		m.Verbosity,
		m.WrapTable,
		"project",
		scopeNames,
		m.ProjectIDs,
		m.Account,
		output,
	)
	if err != nil {
		logger.ErrorM(fmt.Sprintf("Error writing output: %v", err), globals.GCP_PRIVESC_MODULE_NAME)
	}
}
