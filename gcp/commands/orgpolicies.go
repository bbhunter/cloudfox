package commands

import (
	"context"
	"fmt"
	"strings"
	"sync"

	orgpolicyservice "github.com/BishopFox/cloudfox/gcp/services/orgpolicyService"
	"github.com/BishopFox/cloudfox/globals"
	"github.com/BishopFox/cloudfox/internal"
	gcpinternal "github.com/BishopFox/cloudfox/internal/gcp"
	"github.com/spf13/cobra"
)

var GCPOrgPoliciesCommand = &cobra.Command{
	Use:     globals.GCP_ORGPOLICIES_MODULE_NAME,
	Aliases: []string{"orgpolicy", "policies"},
	Short:   "Enumerate organization policies and identify security weaknesses",
	Long: `Enumerate GCP organization policies to identify security configuration weaknesses.

Organization policies control security constraints across GCP resources. This module
identifies policies that may be misconfigured or weakened, creating security risks.

Security-Relevant Policies Analyzed:
- Domain restrictions (iam.allowedPolicyMemberDomains)
- Service account key controls (iam.disableServiceAccountKeyCreation)
- Workload identity restrictions
- Compute security (Shielded VM, OS Login, external IPs)
- Storage security (public access, uniform access)
- SQL security (public IPs, authorized networks)
- GKE security (public endpoints)
- Resource location restrictions

Risk Indicators:
- AllowAll: Policy allows any value (HIGH risk)
- Wildcard patterns: Overly permissive allowed values
- Unenforced: Security constraint not enabled
- Override: Project overrides parent restrictions`,
	Run: runGCPOrgPoliciesCommand,
}

type OrgPoliciesModule struct {
	gcpinternal.BaseGCPModule
	Policies []orgpolicyservice.OrgPolicyInfo
	LootMap  map[string]*internal.LootFile
	mu       sync.Mutex
}

type OrgPoliciesOutput struct {
	Table []internal.TableFile
	Loot  []internal.LootFile
}

func (o OrgPoliciesOutput) TableFiles() []internal.TableFile { return o.Table }
func (o OrgPoliciesOutput) LootFiles() []internal.LootFile   { return o.Loot }

func runGCPOrgPoliciesCommand(cmd *cobra.Command, args []string) {
	cmdCtx, err := gcpinternal.InitializeCommandContext(cmd, globals.GCP_ORGPOLICIES_MODULE_NAME)
	if err != nil {
		return
	}

	module := &OrgPoliciesModule{
		BaseGCPModule: gcpinternal.NewBaseGCPModule(cmdCtx),
		Policies:      []orgpolicyservice.OrgPolicyInfo{},
		LootMap:       make(map[string]*internal.LootFile),
	}
	module.initializeLootFiles()
	module.Execute(cmdCtx.Ctx, cmdCtx.Logger)
}

func (m *OrgPoliciesModule) Execute(ctx context.Context, logger internal.Logger) {
	m.RunProjectEnumeration(ctx, logger, m.ProjectIDs, globals.GCP_ORGPOLICIES_MODULE_NAME, m.processProject)

	if len(m.Policies) == 0 {
		logger.InfoM("No organization policies found (may require orgpolicy.policies.list permission)", globals.GCP_ORGPOLICIES_MODULE_NAME)
		return
	}

	logger.SuccessM(fmt.Sprintf("Found %d organization policy(ies)", len(m.Policies)), globals.GCP_ORGPOLICIES_MODULE_NAME)
	m.writeOutput(ctx, logger)
}

func (m *OrgPoliciesModule) processProject(ctx context.Context, projectID string, logger internal.Logger) {
	if globals.GCP_VERBOSITY >= globals.GCP_VERBOSE_ERRORS {
		logger.InfoM(fmt.Sprintf("Enumerating org policies in project: %s", projectID), globals.GCP_ORGPOLICIES_MODULE_NAME)
	}

	svc := orgpolicyservice.New()
	policies, err := svc.ListProjectPolicies(projectID)
	if err != nil {
		m.CommandCounter.Error++
		gcpinternal.HandleGCPError(err, logger, globals.GCP_ORGPOLICIES_MODULE_NAME,
			fmt.Sprintf("Could not enumerate org policies in project %s", projectID))
		return
	}

	m.mu.Lock()
	m.Policies = append(m.Policies, policies...)
	for _, policy := range policies {
		m.addPolicyToLoot(policy)
	}
	m.mu.Unlock()
}

func (m *OrgPoliciesModule) initializeLootFiles() {
	m.LootMap["orgpolicies-commands"] = &internal.LootFile{
		Name:     "orgpolicies-commands",
		Contents: "# Organization Policy Commands\n# Generated by CloudFox\n# WARNING: Only use with proper authorization\n\n",
	}
}

func (m *OrgPoliciesModule) addPolicyToLoot(policy orgpolicyservice.OrgPolicyInfo) {
	// Extract short constraint name for commands
	constraintName := policy.Constraint
	if strings.HasPrefix(constraintName, "constraints/") {
		constraintName = strings.TrimPrefix(constraintName, "constraints/")
	}

	m.LootMap["orgpolicies-commands"].Contents += fmt.Sprintf(
		"## Constraint: %s (Project: %s)\n",
		policy.Constraint, policy.ProjectID,
	)

	if policy.Description != "" {
		m.LootMap["orgpolicies-commands"].Contents += fmt.Sprintf("# Description: %s\n", policy.Description)
	}

	m.LootMap["orgpolicies-commands"].Contents += fmt.Sprintf(
		"# Enforced: %s, AllowAll: %s, DenyAll: %s, Inherit: %s\n",
		boolToYesNo(policy.Enforced),
		boolToYesNo(policy.AllowAll),
		boolToYesNo(policy.DenyAll),
		boolToYesNo(policy.InheritParent),
	)

	if len(policy.AllowedValues) > 0 {
		m.LootMap["orgpolicies-commands"].Contents += fmt.Sprintf("# Allowed Values: %s\n", strings.Join(policy.AllowedValues, ", "))
	}
	if len(policy.DeniedValues) > 0 {
		m.LootMap["orgpolicies-commands"].Contents += fmt.Sprintf("# Denied Values: %s\n", strings.Join(policy.DeniedValues, ", "))
	}

	m.LootMap["orgpolicies-commands"].Contents += fmt.Sprintf(
		"\n# Describe this policy:\n"+
			"gcloud org-policies describe %s --project=%s\n\n"+
			"# Get effective policy (includes inheritance):\n"+
			"gcloud org-policies describe %s --project=%s --effective\n\n",
		constraintName, policy.ProjectID,
		constraintName, policy.ProjectID,
	)
}

func (m *OrgPoliciesModule) writeOutput(ctx context.Context, logger internal.Logger) {
	// Main policies table
	header := []string{
		"Project Name",
		"Project ID",
		"Constraint",
		"Description",
		"Enforced",
		"Allow All",
		"Deny All",
		"Inherit",
		"Allowed Values",
		"Denied Values",
	}

	var body [][]string
	for _, policy := range m.Policies {
		description := policy.Description
		if description == "" {
			description = "-"
		}

		allowedValues := "-"
		if len(policy.AllowedValues) > 0 {
			allowedValues = strings.Join(policy.AllowedValues, ", ")
		}

		deniedValues := "-"
		if len(policy.DeniedValues) > 0 {
			deniedValues = strings.Join(policy.DeniedValues, ", ")
		}

		body = append(body, []string{
			m.GetProjectName(policy.ProjectID),
			policy.ProjectID,
			policy.Constraint,
			description,
			boolToYesNo(policy.Enforced),
			boolToYesNo(policy.AllowAll),
			boolToYesNo(policy.DenyAll),
			boolToYesNo(policy.InheritParent),
			allowedValues,
			deniedValues,
		})
	}

	// Collect loot files
	var lootFiles []internal.LootFile
	for _, loot := range m.LootMap {
		if loot.Contents != "" && !strings.HasSuffix(loot.Contents, "# WARNING: Only use with proper authorization\n\n") {
			lootFiles = append(lootFiles, *loot)
		}
	}

	tables := []internal.TableFile{
		{
			Name:   "orgpolicies",
			Header: header,
			Body:   body,
		},
	}

	output := OrgPoliciesOutput{Table: tables, Loot: lootFiles}

	scopeNames := make([]string, len(m.ProjectIDs))
	for i, id := range m.ProjectIDs {
		scopeNames[i] = m.GetProjectName(id)
	}

	err := internal.HandleOutputSmart(
		"gcp",
		m.Format,
		m.OutputDirectory,
		m.Verbosity,
		m.WrapTable,
		"project",
		m.ProjectIDs,
		scopeNames,
		m.Account,
		output,
	)
	if err != nil {
		logger.ErrorM(fmt.Sprintf("Error writing output: %v", err), globals.GCP_ORGPOLICIES_MODULE_NAME)
	}
}
