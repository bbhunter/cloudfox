package commands

import (
	"context"
	"fmt"
	"strings"
	"sync"

	logginggapsservice "github.com/BishopFox/cloudfox/gcp/services/loggingGapsService"
	"github.com/BishopFox/cloudfox/globals"
	"github.com/BishopFox/cloudfox/internal"
	gcpinternal "github.com/BishopFox/cloudfox/internal/gcp"
	"github.com/spf13/cobra"
)

var GCPLoggingGapsCommand = &cobra.Command{
	Use:     globals.GCP_LOGGINGGAPS_MODULE_NAME,
	Aliases: []string{"log-gaps", "stealth", "blind-spots"},
	Short:   "Find resources with missing or incomplete logging",
	Long: `Identify logging gaps across GCP resources for stealth assessment.

This module helps identify resources where actions may not be properly logged,
which is valuable for understanding detection blind spots.

Resources Checked:
- Cloud Storage buckets (access logging)
- VPC subnets (flow logs)
- GKE clusters (workload and system logging)
- Cloud SQL instances (query and connection logging)
- Log sinks and exclusions (export gaps)
- Project-level audit logging configuration

Output:
- Resources with disabled or partial logging
- Stealth value rating (CRITICAL, HIGH, MEDIUM, LOW)
- Specific missing log types
- Recommendations for defenders
- Commands for testing detection gaps

Stealth Value Ratings:
- CRITICAL: No logging, actions completely invisible
- HIGH: Significant gaps enabling undetected activity
- MEDIUM: Some logging present but incomplete
- LOW: Minor gaps with limited stealth value`,
	Run: runGCPLoggingGapsCommand,
}

// ------------------------------
// Module Struct
// ------------------------------
type LoggingGapsModule struct {
	gcpinternal.BaseGCPModule

	Gaps         []logginggapsservice.LoggingGap
	AuditConfigs []*logginggapsservice.AuditLogConfig
	LootMap      map[string]*internal.LootFile
	mu           sync.Mutex
}

// ------------------------------
// Output Struct
// ------------------------------
type LoggingGapsOutput struct {
	Table []internal.TableFile
	Loot  []internal.LootFile
}

func (o LoggingGapsOutput) TableFiles() []internal.TableFile { return o.Table }
func (o LoggingGapsOutput) LootFiles() []internal.LootFile   { return o.Loot }

// ------------------------------
// Command Entry Point
// ------------------------------
func runGCPLoggingGapsCommand(cmd *cobra.Command, args []string) {
	cmdCtx, err := gcpinternal.InitializeCommandContext(cmd, globals.GCP_LOGGINGGAPS_MODULE_NAME)
	if err != nil {
		return
	}

	module := &LoggingGapsModule{
		BaseGCPModule: gcpinternal.NewBaseGCPModule(cmdCtx),
		Gaps:          []logginggapsservice.LoggingGap{},
		AuditConfigs:  []*logginggapsservice.AuditLogConfig{},
		LootMap:       make(map[string]*internal.LootFile),
	}

	module.initializeLootFiles()
	module.Execute(cmdCtx.Ctx, cmdCtx.Logger)
}

// ------------------------------
// Module Execution
// ------------------------------
func (m *LoggingGapsModule) Execute(ctx context.Context, logger internal.Logger) {
	m.RunProjectEnumeration(ctx, logger, m.ProjectIDs, globals.GCP_LOGGINGGAPS_MODULE_NAME, m.processProject)

	if len(m.Gaps) == 0 {
		logger.InfoM("No logging gaps found", globals.GCP_LOGGINGGAPS_MODULE_NAME)
		return
	}

	logger.SuccessM(fmt.Sprintf("Found %d logging gap(s)", len(m.Gaps)), globals.GCP_LOGGINGGAPS_MODULE_NAME)

	m.writeOutput(ctx, logger)
}

// ------------------------------
// Project Processor
// ------------------------------
func (m *LoggingGapsModule) processProject(ctx context.Context, projectID string, logger internal.Logger) {
	if globals.GCP_VERBOSITY >= globals.GCP_VERBOSE_ERRORS {
		logger.InfoM(fmt.Sprintf("Scanning logging gaps in project: %s", projectID), globals.GCP_LOGGINGGAPS_MODULE_NAME)
	}

	svc := logginggapsservice.New()
	gaps, auditConfig, err := svc.EnumerateLoggingGaps(projectID)
	if err != nil {
		m.CommandCounter.Error++
		gcpinternal.HandleGCPError(err, logger, globals.GCP_LOGGINGGAPS_MODULE_NAME,
			fmt.Sprintf("Could not enumerate logging gaps in project %s", projectID))
		return
	}

	m.mu.Lock()
	m.Gaps = append(m.Gaps, gaps...)
	if auditConfig != nil {
		m.AuditConfigs = append(m.AuditConfigs, auditConfig)
	}

	for _, gap := range gaps {
		m.addGapToLoot(gap)
	}
	m.mu.Unlock()

	if globals.GCP_VERBOSITY >= globals.GCP_VERBOSE_ERRORS {
		logger.InfoM(fmt.Sprintf("Found %d logging gap(s) in project %s", len(gaps), projectID), globals.GCP_LOGGINGGAPS_MODULE_NAME)
	}
}

// ------------------------------
// Loot File Management
// ------------------------------
func (m *LoggingGapsModule) initializeLootFiles() {
	m.LootMap["logging-gaps-commands"] = &internal.LootFile{
		Name:     "logging-gaps-commands",
		Contents: "# Logging Gaps Commands\n# Generated by CloudFox\n# WARNING: Only use with proper authorization\n\n",
	}
}

func (m *LoggingGapsModule) addGapToLoot(gap logginggapsservice.LoggingGap) {
	m.LootMap["logging-gaps-commands"].Contents += fmt.Sprintf(
		"## %s: %s (Project: %s, Location: %s)\n"+
			"# Status: %s\n"+
			"# Missing:\n",
		gap.ResourceType, gap.ResourceName,
		gap.ProjectID, gap.Location,
		gap.LoggingStatus,
	)
	for _, missing := range gap.MissingLogs {
		m.LootMap["logging-gaps-commands"].Contents += fmt.Sprintf("#   - %s\n", missing)
	}
	m.LootMap["logging-gaps-commands"].Contents += "\n"

	// Add exploit commands
	if len(gap.ExploitCommands) > 0 {
		for _, cmd := range gap.ExploitCommands {
			m.LootMap["logging-gaps-commands"].Contents += cmd + "\n"
		}
		m.LootMap["logging-gaps-commands"].Contents += "\n"
	}
}

// ------------------------------
// Output Generation
// ------------------------------
func (m *LoggingGapsModule) writeOutput(ctx context.Context, logger internal.Logger) {
	header := []string{
		"Project ID",
		"Project Name",
		"Type",
		"Resource",
		"Location",
		"Status",
		"Missing Logs",
	}

	var body [][]string
	for _, gap := range m.Gaps {
		missingLogs := strings.Join(gap.MissingLogs, "; ")

		location := gap.Location
		if location == "" {
			location = "-"
		}

		body = append(body, []string{
			gap.ProjectID,
			m.GetProjectName(gap.ProjectID),
			gap.ResourceType,
			gap.ResourceName,
			location,
			gap.LoggingStatus,
			missingLogs,
		})
	}

	// Collect loot files
	var lootFiles []internal.LootFile
	for _, loot := range m.LootMap {
		if loot.Contents != "" && !strings.HasSuffix(loot.Contents, "# WARNING: Only use with proper authorization\n\n") {
			lootFiles = append(lootFiles, *loot)
		}
	}

	tables := []internal.TableFile{
		{
			Name:   "logging-gaps",
			Header: header,
			Body:   body,
		},
	}

	output := LoggingGapsOutput{
		Table: tables,
		Loot:  lootFiles,
	}

	scopeNames := make([]string, len(m.ProjectIDs))
	for i, id := range m.ProjectIDs {
		scopeNames[i] = m.GetProjectName(id)
	}

	err := internal.HandleOutputSmart(
		"gcp",
		m.Format,
		m.OutputDirectory,
		m.Verbosity,
		m.WrapTable,
		"project",
		m.ProjectIDs,
		scopeNames,
		m.Account,
		output,
	)
	if err != nil {
		logger.ErrorM(fmt.Sprintf("Error writing output: %v", err), globals.GCP_LOGGINGGAPS_MODULE_NAME)
		m.CommandCounter.Error++
	}
}
